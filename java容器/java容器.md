![image-20210223132613996](java%E5%AE%B9%E5%99%A8/image-20210223132613996.png)

## 1. ArrayList

- 初始容量为0,可以通过构造函数指定,初始化数组为空数组

- add时,会将size+1作为minCapacity,

  如果是空数组,会去判断默认容量(10)和minCapacity大小,较大值设置minCapacity;

  如果minCapacity大于当前数组的长度,会进入扩容过程

  扩容后容量是原数组容量的1.5倍,如果空数组的,会用minCapacity作为扩容容量;

  直接将原数组拷贝到新数组;

- get 校验一下,按下标返回值

## 2. linkedList

- 实现了list,deque(双向队列),queue,基于链表的实现

- add 直接创建节点(构造函数里会指向first节点)

- get 判断是在链表的前一段还是后一般,前一半从fisrt节点开始往后遍历,后一半从last节点往前遍历

  |        | Arraylist                         | linkedList    |
  | ------ | --------------------------------- | ------------- |
  | get    | 平均时间O(1)                      | 平均时间O(n), |
  | add    | O(1)                              | O(1)          |
  | delete | O(n),需要移动删除目标之后所有元素 | O(1)          |

  

## 3. hashMap(数组+拉链法)

- 默认构造只设置了负载因子(loadfactory),可以指定初始容量,会设置成大于指定容量的最接近的2次方,比如指定5就是8,15就是16,指定17就是32;

- put 

  - 会key进行hash和扰动函数(目的是hash值的所有位都参与之后的通位计算,使桶位尽量均匀)

  - 先判断数组是否为空,会进行resize,然后判断原数组容量是否,再进行初始化数组;

  - hash后的值与2^n-1进行与运算获取桶位,如果桶位节点是链表头节点,则遍历桶位的链表如果存在相同的key,那就替换原值,返回原值如果不存在,就会加在链表之后,这是尾插法.如果是红黑树走红黑树的插入逻辑

  - 插入后的size如果大于阈值(数组大小乘以负载因子),会进行扩容,扩容主要逻辑就是不大于最大容量下,扩容为原来容量的两倍,并通过hash值或上原容量(hash | cap )区分出两个链表,并迁移到新数组的原桶位或原桶位+原容量的位置;

  - 树化条件 链表大于8,数组容量小于64;

    红黑树转化,将链表挨个写入树中.

  - 红黑树性质

    - 1.根节点为黑色
    - 2.只有两个颜色红色和黑色
    
    - 3.只有红色节点的子节点不能是红色节点
    - 4.从任意一个节点到叶子节点所有的路径上的黑色节点是一致的
    
    - 5.叶子节点都是黑色,nil节点也是黑色,叶子节点就是nil节点


  - 插入自平衡(默认插入节点是红色,后续可以变色)

    - 场景1 插入节点是根节点,变色为黑,退出

    - 场景2 插入节点的父节点时黑色,则已平衡无需平衡,退出

    - 场景3 父节点为红色(不满足性质需要平衡)

      ​		场景3.1 父节点是祖父节点的左子节点

      ​				场景3.1.1  右叔节点存在,且右叔节点为红色,因为性质3,祖父节点必然是黑色节								  点,此时只需要将父节点和右叔节点染黑,祖父节点染红,然后将祖父节点作  								  为不平衡的节点作为下一次插入自平衡过程;
      
      ​				场景3.1.2 右叔节点为黑色(为null也是黑色)
      
      ​						场景3.1.2.1 插入节点是父节点的的右节点(左右结构),以父节点左旋,变成左左结构;因为左旋导致,重置插入节点,父节点和祖父节点指针,进行下一次循环(下一次循环会走3.1.2.2);
      
      ```java
        xpp              xpp
         /                /
      xp  (红)     --->  x  (红)
        \              /
         x (红)       xp (红)
      ```
      
      ​						场景3.1.2.2 插入节点是父节点的左节点(左左结构),父节点变黑,祖父节点变红,以祖父节点右旋,继续下一次自平衡;
      
      ​		场景3.2 父节点是祖父节点的右子节点
      
      ​				场景3.2.1  左叔节点存在,且左叔节点为红色,因为性质3,祖父节点必然是黑色节								  点,此时只需要将父节点和左叔节点染黑,祖父节点染红,然后将祖父节点作  								  为不平衡的节点作为下一次插入自平衡过程;
      
      ​				场景3.1.2  左叔节点为黑色(为null也是黑色)
      
      ​						场景3.1.2.1 插入节点是父节点的的左节点(右左结构),以父节点右旋,变成右右结构;因为右旋导致指针发生变化,重置插入节点、父节点和祖父节点指针,进行下一次循环(下一次循环会走3.1.2.2);
      
      ```java
       	 xpp              xpp
           /                /
           xp  (红)   ---> x  (红)
           \              /
            x (红)       xp (红)
      ```
      
      ​						场景3.1.2.2 插入节点是父节点的右节点(右右结构),父节点变黑,祖父节点变红,以祖父节点右旋,进行下一次自平衡;
    
  - 
     get
     
    ​    找到桶位,如果是桶位是树走红黑树查找,如果桶位是顺着链表找到节点,找不到返回null;
    
  - delete 

      找到节点,如果是树节点,走树的删除,否则,就链表删除;

      树的删除:

    - 因为hashmap的红黑树也维护了一个双向链表,所以先走链表的删除

    - 二叉树删除节点主要就是需要删除节点位置的代替节点,以代替节点做平衡判断

      需要删除的节点如果没有子节点,那么代替节点就是当前节点

      如果有一个子节点,那么代替节点就是该子节点

      如果有两个子节点,需要找到后继节点,先交换后继节点和需要删除的节点颜色,然后交换两者的位置.如果后继节点的右节点存在,则代替节点为后继节点的右节点,如果不存在,需要删除的节点就是代替节点.

      如果代替节点不是需要删除的节点,那么删除需要删除的节点

      如果删除节点是红色,那么直接删除,否则则以代替节点做删除平衡操作
      
    - 删除自平衡,我理不清楚,从源码上看,如果兄弟节点有红节点,则借一个红节点,如果没有,则将兄弟节点染红,以父节点作为不平衡节点,进行下一次自平衡
    
  - 红黑树退化

      - 当扩容后,树分裂后的链表长度小于6
      - 当删除数据,树深为0时

## 4 .TreeMap(底层是红黑树)

(1)默认构造没有比较器,可以传入比较器

(2)put key必须是实现了Comparable接口或者有比较器,不允许为null

   - 如果没有父节点,则构造一个黑色的根节点
   - 如果有比较器,则按照比较器,比对key值,然后插入
   - 如果没有比较器,但key实现了Comparable,则按照Comparable的比较结果
   - 自平衡操作

(3)get 按照比较器,Comparable接口比较

## 5.Linkedhashmap(双向链表+hashmap)

- put时,会在创建节点的时候去追加到链表尾部
- 删除时会在hashmap的扩展点 afterNodeRemoval中删除当前节点

|                 | Treemap                 | HashMap          | LinkedHashMap    |
| --------------- | ----------------------- | ---------------- | ---------------- |
| key,value为null | key不能为null,value可以 | key和value都可以 | key和value都可以 |
| 是否需要扩容    | 不需要                  | 需要             | 需要             |
| 查询            | O(logn)                 | O(1)             | O(1)             |
| 删除            | O(logn)                 | O(1)             | O(1)             |
| 有序            | 有序                    | 无序             | 有序             |

## 6.HashSet 

hashSet的实现其实就是hashMap的实现,实例化时,内部会实例化一个hashmap;

插入是以插入的数据作为key,一个Object全局常量作为value;

对外表现就是hashmap的的key集合

## 7.TreeSet

其实就是TreeMap的实现

## 8.ConcurrentHashMap

- 重要属性

  - baseCount 类似于longAdder的base,用于计数

  - cellsBusy 锁标记位,0表示加锁,1表示未加锁

  - counterCells 类似于longAdder的cell数组,用于计数,分担baseCount叠加数据时的压力

  - sizeCtl 很重要的属性 

    - 负数表示正在初始化或正在resize,-1表示正在初始化数组,-(1+resize的线程)表示正在resize,因为ConcurrentHashMap在resize时,采取的是并发迁移.多个线程来put时,会优先帮助正在扩容的线程一起迁移数据
  - 如果数组未初始化,则其值为创建数组事需要的容量(默认构造为0,非默认构造为传入参数的最近2的n次方);
    - 初始化完之后,则为下次扩容的阈值,也就是当前容量的3/4(n - n>>>2);

  - transferIndex 多线程并发迁移时可以迁移的位置默认是数组容量
  
- 节点种类
  
  - 普通节点,也就是链表节点
  
  ```java
    class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        volatile V val;
        volatile Node<K,V> next;
    
        Node(int hash, K key, V val, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }
    }   
  ```
  
  - forwarding nodes 属于扩容时会用该节点临时替换,需要迁移的临时桶位,其hash值为-1,该节点会有一个一个指向扩容后的数组;
  - treebin节点红黑树的根节点,hash值为-2
  - ReservationNode 节点,专门用于computeIfAbsent and compute的节点
  
- put 过程

  (1)对key做hash,经过扰动函数,进入一个死循环

  (2)判断数组是否为空,初始化数组

  (3)然后获取下标(与上数组容量-1)

  - 如果对应桶位是forwarding node就辅助帮忙迁移;会根据cpu核数和当前数组大小算出一个迁移长度,如果迁移长度比默认的迁移长度小,采用默认的迁移长度.例如长度为64,cpu核数为8,(NCPU > 1) ? (n >>> 3) / NCPU : n)计算结果是8/8就是1,小于默认的16.第一个线程就会迁移48到64的,第二个线程就是32到48

  - 然后会锁住对应桶位的对象,进行双重检查,因为是并发容器,桶位对象可能会被修改

    - 如果是链表,就按照链表的方式插入
  
    - 如果是红黑树,就按照树的方式插入(这个过程参考hashmap的红黑树)
  
  (4)然后总数+1,采用和longAdder一样的方式,cas给基础数据和cell数组叠加

  (5)如果总数>sizeCtl,就会进行扩容
  
  (6)并发迁移主要逻辑算出每个线程迁移的范围,迁移时会锁住当前桶位,如果桶位迁移完毕,那么就会创建一个forwardingnode指向扩容后的表,放在桶位上,直到迁移完毕;
  
- get过程
  
  对key做hash,经过扰动函数,获取到下标,如果下标的hash小于0,表示是treebin节点或forwarding node,走相应的find;forwarding node的查找也是向扩容后的数组进行查找;
  
  如果大于0,则是普通节点,顺着链表找相应的节点
  
  
  
  
  
  