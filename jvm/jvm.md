## 1.运行时数据区域

- 共享的

  - 方法区 1.7 Permant Generation

    ​			 1.8 Metaspace 移到了堆外空间(受本地空间限制),class,方法,方法数据,字符串常量池(移动到了堆内存)

  - 堆内存 java几乎所有的对象都在堆上分配(也有特殊的对象会在栈上分配),分代概念已经不准确了(需要根据不同的垃圾回收器,比如G1仅是逻辑分代,物理已经不分代了)
  
- 非共享区域

  - pc计数器,可以理解为线程执行字节码指令的计数,包括判断,循环,跳转,native方法的pc计数器为空
  
- 虚拟机方法栈 线程私有的,每个方法执行时都会创建一个栈帧入栈;
  
  - 局部变量表 slot基本变量一般占一个slot,double和long 一般占两个,引用变量也会占一个
    - 操作数栈 对变量的赋值,操作,都得入栈操作完后在出栈
    - 动态链接 存储符号引用转为直接引用的地方
  - 本地方法栈 调用native方法使用的栈
  
- 运行时常量池,字节码常量池,字符串常量池
  
  字节码常量池:java代码被编译后的class文件会有contantpool,里面存放了一些字面量(文本字符串,常量名,基本数据类型的值)和符号引用(类的全限定名称,字段名和描述符,方法名和描述符)

## 2.OOM

除了程序计数器外都有可能oom;

- 方法区oom,以前永久代可能因为动态代理,字节码技术动态生成的class,造成空间不够;现在元数据区被迁移到了本地内存,不容易出现,但是可以配置元数据区大小类限制
- 堆内存OOM:被引用的对象无法回收,比如静态引用或者栈内大数据量的对象
- 栈OOM: 一个是栈深度,一个栈空间(可能被变量slot,轻量级锁,操作数栈占用?),不断建立线程也能出现OOM
## 3.判定对象算法

- 引用计数算法,每个对象被引用就计数加一,释放就减一,但是循环引用就不太好解决了

- 可达性分析算法 从GC roots节点开始,遍历对象,如果可以到达,就不回收,不可到达的就会被回收

  GCroots

  - 静态变量,常量引用的对象(比如stringTable引用的对象)

  - 虚拟机栈,native栈引用的对象

## 4.引用

- 强引用 正常对象的引用

- 软引用 softrefrence  concurrentRefrenceHashMap有两个引用级别一个是softReference,另一个weakRefrence,该级别的对象,在内存溢出前会被回收

- 弱引用 weakRefrence 经典的threadLocal使用该引用,再gc时被回收

- 虚引用 和对象何时回收没有关系,仅是会在回收后收到一个通知,nio的directbytebuffer基于此实现堆外内存的回收

## 5 对象

- 对象头

  主要是markword和类型指针(指向class),此外如果是数组,还得记录长度

  - markword主要存放,hashcode,锁标记位,gc分代年龄,偏向线程id,锁记录指针(轻量级锁),重量级锁指针(ObjectMonitor)

    - 锁标记位01,未锁定    hashcode,分代年龄

    - 锁标记位01, 可偏向  偏向锁线程id,偏向锁线程,分代年龄

    - 锁标记位00,轻量级锁 指向线程栈中所记录的指针

    - 锁标记位10 重量级锁 指向重量级锁的指针

    - 锁标记位 11 GC标记

- 实例数据
  
- 对象填充必须是8字节的倍数
  
## 6.对象分配
- 是否符合栈上分配,标量替换的标准,符合则直接在栈上完成分配

- TLAB是否够用

- eden区是否够用,不够用会触发ygc,如果是大对象会直接晋升至老年代(PretenureSizeThreshold)

- 对象晋升

  除了大对象外,超过年龄阈值的对象也会进入老年代;

  动态年龄判断,从小到大的年龄累加超过 TargetSurvivorRatio 比率的,晋升大于该年龄的对象

  空间担保:执行minorgc前,会查看老年代空间是否比新生代存活的对象大和是否允许空间担保,如果都不是,就执行minorgc,否则执行full gc

## 7.垃圾回收算法

- 标记清除算法  效率高,容易产生内存碎片

- 标记复制      效率高,没有内存碎片,但是浪费空间

- 标记整理     效率差,没有内存碎片

## 8.hotspot 算法细节
- 根节点枚举

  采用了OOpMap,来存储一些栈和寄存器上哪些地方是引用

- 安全点,会挂起所有工作线程,在安全点可以认为堆栈不会发生变化
  
  hotspot采用主动式中断,以内存保护陷阱的方法,
  
- 记忆集合卡表 用于判断回收区域和非回收区域,rememberset可以理解为接口,卡表理解为具体实现,卡表是一个数组,记录着内存区域一块特定的内存大小,如果存在着其他区域的内存引用就会被脏
  
  卡表是通过写屏障(write barrier可以理解为一个切面,在赋值时做操作)
  
- 并发的可达性分析(三色标记算法)
  
  白色:表示未被访问的对象
  
  灰色:表示已经访问过的对象,但是它至少还有一个引用还未访问
  
  黑色:表示已经访问过的对象,它的所有引用都被访问过了
  
  漏标:同时满足一下两点
  
  - 赋值器插入了黑色对象指向白色对象
  - 赋值器删除了灰色对象指向白色对象的引用
  
  于是出现了增量更新(当黑色对象指向白色对象时,置灰并记录,cms使用该方法)和原始快照(记录下要删除的引用g1和zGC使用该方法)
  
## 9.垃圾回收器

- serial回收器,会暂停所有线程,单线程回收垃圾(新生代采用复制算法)

- Parnew回收器,多线程并行收集垃圾,只有它能和cms配合使用

- Parallel Scavenge收集器  新生代垃圾回收器,注重吞吐量(代码执行时间/代码执行时间+垃圾回收时间)

- serial old 老年代回收器

- Parallel old  老年代回收器 支持读线程并行回收

- Concurrent Mark Swap 并发回收.可以和用户并发执行 

  - 初始标记,枚举根节点,stw

  - 并发标记,三色标记可以不暂停用户线程,标记垃圾

  - 预清理,标记脏卡,增量更新的数据再扫一遍

  - 重新标记 stw 增量更新的部分

  - 并发清理

    缺点:由于采用标记清除算法会产生碎片,因为并发清理,还会产生浮动垃圾,会导致Con-current Mode 

    Failure采用serial old垃圾回收器来标记整理老年代;CMSInitiatingOccu-pancyFraction达到该参数设置的内存百分比会去整理内存, CMSFullGCsBeforeCompaction经过多少次垃圾回收后,采用整理
- G1
  过程
  
  - 初始标记 stw
  
  - 并发标记
  
  - 最终标记stw
  
  - 筛选回收stw
  
## 10.类加载

1. 加载,通过全限定名获取字节流,并将给类的静态结构在方法区生成对应的数据结构,创建java.lang.Class类

2. 连接

   - 验证 文件格式验证,元数据验证(语义分析),字节码验证(保证不会出现危害虚拟机的指令),符号引用验证(访问权限)
   - 准备,会给静态变量赋初始值
   - 解析 符号引用,转为直接引用
     - 类接口解析,会去加载为加载的类
     - 字段解析
     - 类方法解析
     - 接口方法解析

3. 初始化     为类变量赋值,静态代码块赋值

4. 使用  

5. 卸载

## 11类加载时机

- new实例化对象,invokestatic调用静态方法,putstatic调用或设置静态变量

- 反射使用类时

- 初始化类时,父类还没有加载,会加载父类

- main函数主类

- methodhandle方法句柄

- 接口的默认方法,如果接口的实现初始化,该接口也必须初始化

## 12JMM

针对多线程读写数据内存的规范

- 可见性 可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。volatile,happen-before原则
- 原子性 基本数据的读写或者(volatile+long,double),sychronize
- 有序性 As-If-Serial 

volatile: 保证可见性,禁止指令重排,插入内存屏障实现.双重检查单例就用volatile防止指令重排

happen-before原则

- 管程锁定原则 unlock,lock

- volatile原则

- 线程启动原则

- 线程终结

- 线程中断

- 对象终结规则

- 传递性

## 13 java线程状态改变

- new 刚创建,未启动
- runable包括操作系统的ready和running,调用start后(包括等待时间分片)
- waiting 无限期等待调用wait,join,park
- Time_waiting
- block状态 ,等待获取排他锁,比如synchronize
- terminate 结束
## 14 锁升级
- 线程进入sychronize持有的对象

- 判断是否可偏向,可偏向则将当前线程id,线程时间放入markword

- 不可偏向或出现竞争(cas无法将自己线程id放入markword),升级为轻量级锁

- 升级轻量级锁的线程会去检查持有偏向锁的线程是否在sychronize代码块中未出来,如果未出来,则会将其升级为轻量级锁,,如果出来则自己升级为轻量级锁

- 轻量级锁会自旋抢锁(自适应自旋),如果在一定条件为抢不到锁,会膨胀成重量级锁,同时会遍历找到持有轻量级锁的线程,将它升级为重量级锁

- 重量级包含一个entryList,一个waitSet

## 15 锁消除,锁粗化

- 锁消除,虚拟机会对不会出现线程安全问题的代码,进行锁消除,比如对stringbuffer加锁
- 锁粗化,虚拟机会对循环体中加锁的代码,进行扩大,无需每次加锁